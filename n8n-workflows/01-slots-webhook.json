{
  "name": "Rodopi Dent - Get Available Slots",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "GET",
        "path": "slots-webhook",
        "responseMode": "responseNode",
        "options": {
          "allowedOrigins": "*"
        }
      },
      "id": "webhook-slots",
      "name": "Webhook - Get Slots",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [0, 0],
      "webhookId": "slots-webhook"
    },
    {
      "parameters": {
        "operation": "read",
        "documentId": {
          "__rl": true,
          "mode": "id",
          "value": "1hv4XAfHhScA40Bm1kQ3I-Ih4SJuCBpOJxTOYDNb167g"
        },
        "sheetName": {
          "__rl": true,
          "mode": "name",
          "value": "Appointments"
        },
        "options": {
          "returnAllMatches": true
        }
      },
      "id": "sheets-read",
      "name": "Get Appointments",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.5,
      "position": [220, 0],
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "",
          "name": "Google Sheets"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Get date from query parameter\nconst queryDate = $('Webhook - Get Slots').first().json.query.date;\n\nif (!queryDate) {\n  return [{ json: { error: 'Date parameter is required', slots: [] } }];\n}\n\n// Parse the requested date\nconst requestedDate = new Date(queryDate);\nconst dayOfWeek = requestedDate.getDay();\n\n// Check if it's a working day (Monday-Friday = 1-5)\nconst workingDays = [1, 2, 3, 4, 5];\nif (!workingDays.includes(dayOfWeek)) {\n  return [{ json: { date: queryDate, slots: [], message: 'Неработен ден' } }];\n}\n\n// Working hours configuration\nconst workingHours = {\n  morning: { start: '09:00', end: '12:00' },\n  afternoon: { start: '13:30', end: '17:00' }\n};\n\n// SLOT_INTERVAL = 30 minutes (how often slots appear)\nconst slotInterval = 30;\n\n// Helper function to convert time to minutes\nfunction timeToMinutes(time) {\n  const [hours, minutes] = time.split(':').map(Number);\n  return hours * 60 + minutes;\n}\n\n// Helper function to convert minutes to time\nfunction minutesToTime(mins) {\n  const hours = Math.floor(mins / 60);\n  const minutes = mins % 60;\n  return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;\n}\n\n// Generate all possible 30-minute slots\nconst allSlots = [];\n\n// Morning slots (09:00 - 12:00)\nlet current = timeToMinutes(workingHours.morning.start);\nconst morningEnd = timeToMinutes(workingHours.morning.end);\nwhile (current < morningEnd) {\n  allSlots.push(minutesToTime(current));\n  current += slotInterval;\n}\n\n// Afternoon slots (13:30 - 17:00)\ncurrent = timeToMinutes(workingHours.afternoon.start);\nconst afternoonEnd = timeToMinutes(workingHours.afternoon.end);\nwhile (current < afternoonEnd) {\n  allSlots.push(minutesToTime(current));\n  current += slotInterval;\n}\n\n// Get booked appointments for this date\nconst appointments = $('Get Appointments').all();\n\n// Build list of blocked time ranges (considering duration)\nconst blockedRanges = [];\nappointments\n  .filter(apt => {\n    const aptDate = apt.json.date;\n    const status = apt.json.status;\n    // Only count non-cancelled appointments\n    return aptDate === queryDate && status !== 'cancelled';\n  })\n  .forEach(apt => {\n    const startMinutes = timeToMinutes(apt.json.startTime);\n    const duration = parseInt(apt.json.duration) || 30;\n    const endMinutes = startMinutes + duration;\n    blockedRanges.push({ start: startMinutes, end: endMinutes });\n  });\n\n// Check if a slot conflicts with any blocked range\nfunction isSlotBlocked(slotTime) {\n  const slotMinutes = timeToMinutes(slotTime);\n  // Check if this slot's start time falls within any blocked range\n  return blockedRanges.some(range => {\n    return slotMinutes >= range.start && slotMinutes < range.end;\n  });\n}\n\n// Filter out blocked slots\nconst availableSlots = allSlots.filter(slot => !isSlotBlocked(slot));\n\n// Also return booked slots info for debugging\nconst bookedSlots = appointments\n  .filter(apt => apt.json.date === queryDate && apt.json.status !== 'cancelled')\n  .map(apt => ({\n    startTime: apt.json.startTime,\n    duration: apt.json.duration,\n    patientName: apt.json.patientName\n  }));\n\nreturn [{\n  json: {\n    date: queryDate,\n    slots: availableSlots,\n    totalSlots: allSlots.length,\n    bookedCount: bookedSlots.length,\n    bookedSlots: bookedSlots\n  }\n}];"
      },
      "id": "code-filter",
      "name": "Calculate Available Slots",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [440, 0]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {
          "responseHeaders": {
            "entries": [
              {
                "name": "Access-Control-Allow-Origin",
                "value": "*"
              }
            ]
          }
        }
      },
      "id": "response",
      "name": "Respond with Slots",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [660, 0]
    }
  ],
  "connections": {
    "Webhook - Get Slots": {
      "main": [
        [
          {
            "node": "Get Appointments",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Appointments": {
      "main": [
        [
          {
            "node": "Calculate Available Slots",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Calculate Available Slots": {
      "main": [
        [
          {
            "node": "Respond with Slots",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "tags": [
    {
      "name": "Rodopi Dent"
    }
  ]
}
